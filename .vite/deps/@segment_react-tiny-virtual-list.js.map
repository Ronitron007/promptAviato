{
  "version": 3,
  "sources": ["../../../../../../../aviato-ui/node_modules/@segment/react-tiny-virtual-list/build/react-tiny-virtual-list.es.js"],
  "sourcesContent": ["import { PureComponent, createElement } from 'react';\nimport { array, arrayOf, func, number, object, oneOf, oneOfType, string } from 'prop-types';\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\n\nvar ALIGNMENT;\n(function (ALIGNMENT) {\n    ALIGNMENT[\"AUTO\"] = \"auto\";\n    ALIGNMENT[\"START\"] = \"start\";\n    ALIGNMENT[\"CENTER\"] = \"center\";\n    ALIGNMENT[\"END\"] = \"end\";\n})(ALIGNMENT || (ALIGNMENT = {}));\nvar DIRECTION;\n(function (DIRECTION) {\n    DIRECTION[\"HORIZONTAL\"] = \"horizontal\";\n    DIRECTION[\"VERTICAL\"] = \"vertical\";\n})(DIRECTION || (DIRECTION = {}));\nvar SCROLL_CHANGE_REASON;\n(function (SCROLL_CHANGE_REASON) {\n    SCROLL_CHANGE_REASON[\"OBSERVED\"] = \"observed\";\n    SCROLL_CHANGE_REASON[\"REQUESTED\"] = \"requested\";\n})(SCROLL_CHANGE_REASON || (SCROLL_CHANGE_REASON = {}));\nvar scrollProp = (_a = {}, _a[DIRECTION.VERTICAL] = 'scrollTop', _a[DIRECTION.HORIZONTAL] = 'scrollLeft', _a);\nvar sizeProp = (_b = {}, _b[DIRECTION.VERTICAL] = 'height', _b[DIRECTION.HORIZONTAL] = 'width', _b);\nvar positionProp = (_c = {}, _c[DIRECTION.VERTICAL] = 'top', _c[DIRECTION.HORIZONTAL] = 'left', _c);\nvar marginProp = (_d = {}, _d[DIRECTION.VERTICAL] = 'marginTop', _d[DIRECTION.HORIZONTAL] = 'marginLeft', _d);\nvar oppositeMarginProp = (_e = {}, _e[DIRECTION.VERTICAL] = 'marginBottom', _e[DIRECTION.HORIZONTAL] = 'marginRight', _e);\nvar _a;\nvar _b;\nvar _c;\nvar _d;\nvar _e;\n\n/* Forked from react-virtualized ðŸ’– */\nvar SizeAndPositionManager = /** @class */function () {\n    function SizeAndPositionManager(_a) {\n        var itemCount = _a.itemCount,\n            itemSizeGetter = _a.itemSizeGetter,\n            estimatedItemSize = _a.estimatedItemSize;\n        this.itemSizeGetter = itemSizeGetter;\n        this.itemCount = itemCount;\n        this.estimatedItemSize = estimatedItemSize;\n        // Cache of size and position data for items, mapped by item index.\n        this.itemSizeAndPositionData = {};\n        // Measurements for items up to this index can be trusted; items afterward should be estimated.\n        this.lastMeasuredIndex = -1;\n    }\n    SizeAndPositionManager.prototype.updateConfig = function (_a) {\n        var itemCount = _a.itemCount,\n            itemSizeGetter = _a.itemSizeGetter,\n            estimatedItemSize = _a.estimatedItemSize;\n        if (itemCount != null) {\n            this.itemCount = itemCount;\n        }\n        if (estimatedItemSize != null) {\n            this.estimatedItemSize = estimatedItemSize;\n        }\n        if (itemSizeGetter != null) {\n            this.itemSizeGetter = itemSizeGetter;\n        }\n    };\n    SizeAndPositionManager.prototype.getLastMeasuredIndex = function () {\n        return this.lastMeasuredIndex;\n    };\n    /**\n     * This method returns the size and position for the item at the specified index.\n     * It just-in-time calculates (or used cached values) for items leading up to the index.\n     */\n    SizeAndPositionManager.prototype.getSizeAndPositionForIndex = function (index) {\n        if (index < 0 || index >= this.itemCount) {\n            throw Error(\"Requested index \" + index + \" is outside of range 0..\" + this.itemCount);\n        }\n        if (index > this.lastMeasuredIndex) {\n            var lastMeasuredSizeAndPosition = this.getSizeAndPositionOfLastMeasuredItem();\n            var offset = lastMeasuredSizeAndPosition.offset + lastMeasuredSizeAndPosition.size;\n            for (var i = this.lastMeasuredIndex + 1; i <= index; i++) {\n                var size = this.itemSizeGetter(i);\n                if (size == null || isNaN(size)) {\n                    throw Error(\"Invalid size returned for index \" + i + \" of value \" + size);\n                }\n                this.itemSizeAndPositionData[i] = {\n                    offset: offset,\n                    size: size\n                };\n                offset += size;\n            }\n            this.lastMeasuredIndex = index;\n        }\n        return this.itemSizeAndPositionData[index];\n    };\n    SizeAndPositionManager.prototype.getSizeAndPositionOfLastMeasuredItem = function () {\n        return this.lastMeasuredIndex >= 0 ? this.itemSizeAndPositionData[this.lastMeasuredIndex] : { offset: 0, size: 0 };\n    };\n    /**\n     * Total size of all items being measured.\n     * This value will be completedly estimated initially.\n     * As items as measured the estimate will be updated.\n     */\n    SizeAndPositionManager.prototype.getTotalSize = function () {\n        var lastMeasuredSizeAndPosition = this.getSizeAndPositionOfLastMeasuredItem();\n        return lastMeasuredSizeAndPosition.offset + lastMeasuredSizeAndPosition.size + (this.itemCount - this.lastMeasuredIndex - 1) * this.estimatedItemSize;\n    };\n    /**\n     * Determines a new offset that ensures a certain item is visible, given the alignment.\n     *\n     * @param align Desired alignment within container; one of \"start\" (default), \"center\", or \"end\"\n     * @param containerSize Size (width or height) of the container viewport\n     * @return Offset to use to ensure the specified item is visible\n     */\n    SizeAndPositionManager.prototype.getUpdatedOffsetForIndex = function (_a) {\n        var _b = _a.align,\n            align = _b === void 0 ? ALIGNMENT.START : _b,\n            containerSize = _a.containerSize,\n            currentOffset = _a.currentOffset,\n            targetIndex = _a.targetIndex;\n        if (containerSize <= 0) {\n            return 0;\n        }\n        var datum = this.getSizeAndPositionForIndex(targetIndex);\n        var maxOffset = datum.offset;\n        var minOffset = maxOffset - containerSize + datum.size;\n        var idealOffset;\n        switch (align) {\n            case ALIGNMENT.END:\n                idealOffset = minOffset;\n                break;\n            case ALIGNMENT.CENTER:\n                idealOffset = maxOffset - (containerSize - datum.size) / 2;\n                break;\n            case ALIGNMENT.START:\n                idealOffset = maxOffset;\n                break;\n            default:\n                idealOffset = Math.max(minOffset, Math.min(maxOffset, currentOffset));\n        }\n        var totalSize = this.getTotalSize();\n        return Math.max(0, Math.min(totalSize - containerSize, idealOffset));\n    };\n    SizeAndPositionManager.prototype.getVisibleRange = function (_a) {\n        var containerSize = _a.containerSize,\n            offset = _a.offset,\n            overscanCount = _a.overscanCount;\n        var totalSize = this.getTotalSize();\n        if (totalSize === 0) {\n            return {};\n        }\n        var maxOffset = offset + containerSize;\n        var start = this.findNearestItem(offset);\n        if (typeof start === 'undefined') {\n            throw Error(\"Invalid offset \" + offset + \" specified\");\n        }\n        var datum = this.getSizeAndPositionForIndex(start);\n        offset = datum.offset + datum.size;\n        var stop = start;\n        while (offset < maxOffset && stop < this.itemCount - 1) {\n            stop++;\n            offset += this.getSizeAndPositionForIndex(stop).size;\n        }\n        if (overscanCount) {\n            start = Math.max(0, start - overscanCount);\n            stop = Math.min(stop + overscanCount, this.itemCount - 1);\n        }\n        return {\n            start: start,\n            stop: stop\n        };\n    };\n    /**\n     * Clear all cached values for items after the specified index.\n     * This method should be called for any item that has changed its size.\n     * It will not immediately perform any calculations; they'll be performed the next time getSizeAndPositionForIndex() is called.\n     */\n    SizeAndPositionManager.prototype.resetItem = function (index) {\n        this.lastMeasuredIndex = Math.min(this.lastMeasuredIndex, index - 1);\n    };\n    /**\n     * Searches for the item (index) nearest the specified offset.\n     *\n     * If no exact match is found the next lowest item index will be returned.\n     * This allows partially visible items (with offsets just before/above the fold) to be visible.\n     */\n    SizeAndPositionManager.prototype.findNearestItem = function (offset) {\n        if (isNaN(offset)) {\n            throw Error(\"Invalid offset \" + offset + \" specified\");\n        }\n        // Our search algorithms find the nearest match at or below the specified offset.\n        // So make sure the offset is at least 0 or no match will be found.\n        offset = Math.max(0, offset);\n        var lastMeasuredSizeAndPosition = this.getSizeAndPositionOfLastMeasuredItem();\n        var lastMeasuredIndex = Math.max(0, this.lastMeasuredIndex);\n        if (lastMeasuredSizeAndPosition.offset >= offset) {\n            // If we've already measured items within this range just use a binary search as it's faster.\n            return this.binarySearch({\n                high: lastMeasuredIndex,\n                low: 0,\n                offset: offset\n            });\n        } else {\n            // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.\n            // The exponential search avoids pre-computing sizes for the full set of items as a binary search would.\n            // The overall complexity for this approach is O(log n).\n            return this.exponentialSearch({\n                index: lastMeasuredIndex,\n                offset: offset\n            });\n        }\n    };\n    SizeAndPositionManager.prototype.binarySearch = function (_a) {\n        var low = _a.low,\n            high = _a.high,\n            offset = _a.offset;\n        var middle = 0;\n        var currentOffset = 0;\n        while (low <= high) {\n            middle = low + Math.floor((high - low) / 2);\n            currentOffset = this.getSizeAndPositionForIndex(middle).offset;\n            if (currentOffset === offset) {\n                return middle;\n            } else if (currentOffset < offset) {\n                low = middle + 1;\n            } else if (currentOffset > offset) {\n                high = middle - 1;\n            }\n        }\n        if (low > 0) {\n            return low - 1;\n        }\n        return 0;\n    };\n    SizeAndPositionManager.prototype.exponentialSearch = function (_a) {\n        var index = _a.index,\n            offset = _a.offset;\n        var interval = 1;\n        while (index < this.itemCount && this.getSizeAndPositionForIndex(index).offset < offset) {\n            index += interval;\n            interval *= 2;\n        }\n        return this.binarySearch({\n            high: Math.min(index, this.itemCount - 1),\n            low: Math.floor(index / 2),\n            offset: offset\n        });\n    };\n    return SizeAndPositionManager;\n}();\n\nvar STYLE_WRAPPER = {\n    overflow: 'auto',\n    willChange: 'transform',\n    WebkitOverflowScrolling: 'touch'\n};\nvar STYLE_INNER = {\n    position: 'relative',\n    width: '100%',\n    minHeight: '100%'\n};\nvar STYLE_ITEM = {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    width: '100%'\n};\nvar STYLE_STICKY_ITEM = __assign({}, STYLE_ITEM, { position: 'sticky' });\nvar VirtualList = /** @class */function (_super) {\n    __extends(VirtualList, _super);\n    function VirtualList() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.itemSizeGetter = function (itemSize) {\n            return function (index) {\n                return _this.getSize(index, itemSize);\n            };\n        };\n        _this.sizeAndPositionManager = new SizeAndPositionManager({\n            itemCount: _this.props.itemCount,\n            itemSizeGetter: _this.itemSizeGetter(_this.props.itemSize),\n            estimatedItemSize: _this.getEstimatedItemSize()\n        });\n        _this.state = {\n            offset: _this.props.scrollOffset || _this.props.scrollToIndex != null && _this.getOffsetForIndex(_this.props.scrollToIndex) || 0,\n            scrollChangeReason: SCROLL_CHANGE_REASON.REQUESTED\n        };\n        _this.styleCache = {};\n        _this.getRef = function (node) {\n            _this.rootNode = node;\n        };\n        _this.handleScroll = function (event) {\n            var onScroll = _this.props.onScroll;\n            var offset = _this.getNodeOffset();\n            if (offset < 0 || _this.state.offset === offset || event.target !== _this.rootNode) {\n                return;\n            }\n            _this.setState({\n                offset: offset,\n                scrollChangeReason: SCROLL_CHANGE_REASON.OBSERVED\n            });\n            if (typeof onScroll === 'function') {\n                onScroll(offset, event);\n            }\n        };\n        return _this;\n    }\n    VirtualList.prototype.componentDidMount = function () {\n        var _a = this.props,\n            scrollOffset = _a.scrollOffset,\n            scrollToIndex = _a.scrollToIndex;\n        this.rootNode.addEventListener('scroll', this.handleScroll, {\n            passive: true\n        });\n        if (scrollOffset != null) {\n            this.scrollTo(scrollOffset);\n        } else if (scrollToIndex != null) {\n            this.scrollTo(this.getOffsetForIndex(scrollToIndex));\n        }\n    };\n    VirtualList.prototype.UNSAFE_componentWillReceiveProps = function (nextProps) {\n        var _a = this.props,\n            estimatedItemSize = _a.estimatedItemSize,\n            itemCount = _a.itemCount,\n            itemSize = _a.itemSize,\n            scrollOffset = _a.scrollOffset,\n            scrollToAlignment = _a.scrollToAlignment,\n            scrollToIndex = _a.scrollToIndex;\n        var scrollPropsHaveChanged = nextProps.scrollToIndex !== scrollToIndex || nextProps.scrollToAlignment !== scrollToAlignment;\n        var itemPropsHaveChanged = nextProps.itemCount !== itemCount || nextProps.itemSize !== itemSize || nextProps.estimatedItemSize !== estimatedItemSize;\n        if (nextProps.itemSize !== itemSize) {\n            this.sizeAndPositionManager.updateConfig({\n                itemSizeGetter: this.itemSizeGetter(nextProps.itemSize)\n            });\n        }\n        if (nextProps.itemCount !== itemCount || nextProps.estimatedItemSize !== estimatedItemSize) {\n            this.sizeAndPositionManager.updateConfig({\n                itemCount: nextProps.itemCount,\n                estimatedItemSize: this.getEstimatedItemSize(nextProps)\n            });\n        }\n        if (itemPropsHaveChanged) {\n            this.recomputeSizes();\n        }\n        if (nextProps.scrollOffset !== scrollOffset) {\n            this.setState({\n                offset: nextProps.scrollOffset || 0,\n                scrollChangeReason: SCROLL_CHANGE_REASON.REQUESTED\n            });\n        } else if (typeof nextProps.scrollToIndex === 'number' && (scrollPropsHaveChanged || itemPropsHaveChanged)) {\n            this.setState({\n                offset: this.getOffsetForIndex(nextProps.scrollToIndex, nextProps.scrollToAlignment, nextProps.itemCount),\n                scrollChangeReason: SCROLL_CHANGE_REASON.REQUESTED\n            });\n        }\n    };\n    VirtualList.prototype.componentDidUpdate = function (_, prevState) {\n        var _a = this.state,\n            offset = _a.offset,\n            scrollChangeReason = _a.scrollChangeReason;\n        if (prevState.offset !== offset && scrollChangeReason === SCROLL_CHANGE_REASON.REQUESTED) {\n            this.scrollTo(offset);\n        }\n    };\n    VirtualList.prototype.componentWillUnmount = function () {\n        this.rootNode.removeEventListener('scroll', this.handleScroll);\n    };\n    VirtualList.prototype.scrollTo = function (value) {\n        var _a = this.props.scrollDirection,\n            scrollDirection = _a === void 0 ? DIRECTION.VERTICAL : _a;\n        this.rootNode[scrollProp[scrollDirection]] = value;\n    };\n    VirtualList.prototype.getOffsetForIndex = function (index, scrollToAlignment, itemCount) {\n        if (scrollToAlignment === void 0) {\n            scrollToAlignment = this.props.scrollToAlignment;\n        }\n        if (itemCount === void 0) {\n            itemCount = this.props.itemCount;\n        }\n        var _a = this.props.scrollDirection,\n            scrollDirection = _a === void 0 ? DIRECTION.VERTICAL : _a;\n        if (index < 0 || index >= itemCount) {\n            index = 0;\n        }\n        return this.sizeAndPositionManager.getUpdatedOffsetForIndex({\n            align: scrollToAlignment,\n            containerSize: this.props[sizeProp[scrollDirection]],\n            currentOffset: this.state && this.state.offset || 0,\n            targetIndex: index\n        });\n    };\n    VirtualList.prototype.recomputeSizes = function (startIndex) {\n        if (startIndex === void 0) {\n            startIndex = 0;\n        }\n        this.styleCache = {};\n        this.sizeAndPositionManager.resetItem(startIndex);\n    };\n    VirtualList.prototype.render = function () {\n        var _this = this;\n        var _a = this.props,\n            estimatedItemSize = _a.estimatedItemSize,\n            height = _a.height,\n            _b = _a.overscanCount,\n            overscanCount = _b === void 0 ? 3 : _b,\n            renderItem = _a.renderItem,\n            itemCount = _a.itemCount,\n            itemSize = _a.itemSize,\n            onItemsRendered = _a.onItemsRendered,\n            onScroll = _a.onScroll,\n            _c = _a.scrollDirection,\n            scrollDirection = _c === void 0 ? DIRECTION.VERTICAL : _c,\n            scrollOffset = _a.scrollOffset,\n            scrollToIndex = _a.scrollToIndex,\n            scrollToAlignment = _a.scrollToAlignment,\n            stickyIndices = _a.stickyIndices,\n            style = _a.style,\n            width = _a.width,\n            props = __rest(_a, [\"estimatedItemSize\", \"height\", \"overscanCount\", \"renderItem\", \"itemCount\", \"itemSize\", \"onItemsRendered\", \"onScroll\", \"scrollDirection\", \"scrollOffset\", \"scrollToIndex\", \"scrollToAlignment\", \"stickyIndices\", \"style\", \"width\"]);\n        var offset = this.state.offset;\n        var _d = this.sizeAndPositionManager.getVisibleRange({\n            containerSize: this.props[sizeProp[scrollDirection]] || 0,\n            offset: offset,\n            overscanCount: overscanCount\n        }),\n            start = _d.start,\n            stop = _d.stop;\n        var items = [];\n        var wrapperStyle = __assign({}, STYLE_WRAPPER, style, { height: height, width: width });\n        var innerStyle = __assign({}, STYLE_INNER, (_e = {}, _e[sizeProp[scrollDirection]] = this.sizeAndPositionManager.getTotalSize(), _e));\n        if (stickyIndices != null && stickyIndices.length !== 0) {\n            stickyIndices.forEach(function (index) {\n                return items.push(renderItem({\n                    index: index,\n                    style: _this.getStyle(index, true)\n                }));\n            });\n            if (scrollDirection === DIRECTION.HORIZONTAL) {\n                innerStyle.display = 'flex';\n            }\n        }\n        if (typeof start !== 'undefined' && typeof stop !== 'undefined') {\n            for (var index = start; index <= stop; index++) {\n                if (stickyIndices != null && stickyIndices.includes(index)) {\n                    continue;\n                }\n                items.push(renderItem({\n                    index: index,\n                    style: this.getStyle(index, false)\n                }));\n            }\n            if (typeof onItemsRendered === 'function') {\n                onItemsRendered({\n                    startIndex: start,\n                    stopIndex: stop\n                });\n            }\n        }\n        return createElement(\"div\", __assign({ ref: this.getRef }, props, { style: wrapperStyle }), createElement(\"div\", { style: innerStyle }, items));\n        var _e;\n    };\n    VirtualList.prototype.getNodeOffset = function () {\n        var _a = this.props.scrollDirection,\n            scrollDirection = _a === void 0 ? DIRECTION.VERTICAL : _a;\n        return this.rootNode[scrollProp[scrollDirection]];\n    };\n    VirtualList.prototype.getEstimatedItemSize = function (props) {\n        if (props === void 0) {\n            props = this.props;\n        }\n        return props.estimatedItemSize || typeof props.itemSize === 'number' && props.itemSize || 50;\n    };\n    VirtualList.prototype.getSize = function (index, itemSize) {\n        if (typeof itemSize === 'function') {\n            return itemSize(index);\n        }\n        return Array.isArray(itemSize) ? itemSize[index] : itemSize;\n    };\n    VirtualList.prototype.getStyle = function (index, sticky) {\n        var style = this.styleCache[index];\n        if (style) {\n            return style;\n        }\n        var _a = this.props.scrollDirection,\n            scrollDirection = _a === void 0 ? DIRECTION.VERTICAL : _a;\n        var _b = this.sizeAndPositionManager.getSizeAndPositionForIndex(index),\n            size = _b.size,\n            offset = _b.offset;\n        return this.styleCache[index] = sticky ? __assign({}, STYLE_STICKY_ITEM, (_c = {}, _c[sizeProp[scrollDirection]] = size, _c[marginProp[scrollDirection]] = offset, _c[oppositeMarginProp[scrollDirection]] = -(offset + size), _c.zIndex = 1, _c)) : __assign({}, STYLE_ITEM, (_d = {}, _d[sizeProp[scrollDirection]] = size, _d[positionProp[scrollDirection]] = offset, _d));\n        var _c, _d;\n    };\n    VirtualList.defaultProps = {\n        overscanCount: 3,\n        scrollDirection: DIRECTION.VERTICAL,\n        width: '100%'\n    };\n    VirtualList.propTypes = {\n        estimatedItemSize: number,\n        height: oneOfType([number, string]).isRequired,\n        itemCount: number.isRequired,\n        itemSize: oneOfType([number, array, func]).isRequired,\n        onScroll: func,\n        onItemsRendered: func,\n        overscanCount: number,\n        renderItem: func.isRequired,\n        scrollOffset: number,\n        scrollToIndex: number,\n        scrollToAlignment: oneOf([ALIGNMENT.AUTO, ALIGNMENT.START, ALIGNMENT.CENTER, ALIGNMENT.END]),\n        scrollDirection: oneOf([DIRECTION.HORIZONTAL, DIRECTION.VERTICAL]),\n        stickyIndices: arrayOf(number),\n        style: object,\n        width: oneOfType([number, string])\n    };\n    return VirtualList;\n}(PureComponent);\n\nexport { DIRECTION as ScrollDirection };\nexport default VirtualList;\n"],
  "mappings": "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",
  "names": ["d", "b", "__assign", "ALIGNMENT", "DIRECTION", "SCROLL_CHANGE_REASON", "SizeAndPositionManager", "_a", "_b", "VirtualList", "_c", "_d", "_e", "index"]
}
